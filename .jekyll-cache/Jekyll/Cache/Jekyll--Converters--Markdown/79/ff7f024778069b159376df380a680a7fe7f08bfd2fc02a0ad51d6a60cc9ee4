I"Ø<p>I was recently directed towards Dave Cheney‚Äôs article <a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis"><em>Functional options for friendly
APIs</em></a> where he shares his
thoughts on designs for optional parameters in APIs. Dave ends with a proposal for <em>functional</em>
arguments that are optionally passed to a type constructor. There is no question this design is
superior to having a single constructor with lots of arguments.</p>

<p>However:</p>

<p class="notice">Dave‚Äôs design is overkill for 99% of use cases and imposes an unnecessary tax on both the maintainer
and the consumer of these APIs.</p>

<p>Developers integrating with these APIs are <em>consumers</em>, so are readers (aka. code reviewers).</p>

<h2 id="my-proposal">My proposal</h2>

<p>A <em>simpler</em> alternative: two constructors, one is default, the other accepts a <em>config</em> struct.</p>

<p>Here is my proposed design for Dave‚Äôs constructors in <a href="https://github.com/pkg/term">term</a>:</p>

<p>{% highlight go %}
package term</p>

<p>// I identified just three options after a quick scan of the README:
// Baud rate, and either CBreakMode or RawMode.
type Options struct {
    CBreakMode bool  // Defaults to RawMode if false
    Baud               int
}</p>

<p>func Default(name string) (*Term, error) {‚Ä¶}</p>

<p>func Custom(name string, options Options) (*Term, error) {‚Ä¶}
{% endhighlight %}</p>

<h2 id="what-we-gain">What we gain‚Ä¶</h2>

<h3 id="in-terms-of-usage">In terms of usage</h3>

<p>Decreased verbosity: occurrences of the symbol <code class="language-plaintext highlighter-rouge">term</code> is decreased. The magnitude of this benefit
increases linearly with the number of optional parameters:</p>

<p>{% highlight go %}
package consumer</p>

<p>import ‚Äúgithub.com/pkg/term‚Äù</p>

<p>func DaveDesign() {
    // default
    term, err := term.Open(‚Äú/dev/ttyUSB0‚Äù)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>// custom
term, err := term.Open(
    "/dev/ttyUSB0",
    term.Speed(57600),
    term.CBreakMode,
) }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>func MyDesign() {
    // A ctor named ‚ÄòDefault‚Äô immediately conveys the possibility of
    // customization to a consumer
    term, err := term.Default(‚Äú/dev/ttyUSB0‚Äù)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>// custom
term, err := term.Custom(
    "/dev/ttyUSB0",
    term.Options{
        Baud:               57600,
        CBreakMode: true,
    }
) } {% endhighlight %}
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="in-terms-of-maintenance">In terms of maintenance</h3>

<p>Decreased number of unit tests: reducing the set of options to a <a href="https://en.wikipedia.org/wiki/Value_object">value object</a> renders tests for them <em>needless</em>.</p>

<h2 id="what-we-lose">What we lose‚Ä¶</h2>

<h3 id="in-terms-of-usage-1">In terms of usage</h3>

<p>Nothing as far as I can see.</p>

<p>The symbol <code class="language-plaintext highlighter-rouge">Default</code> clearly signals the possibility of custom <code class="language-plaintext highlighter-rouge">Term</code>s such that a developer
consuming this API would seek out alternatives if required. This means this design has no added
confusing aspects.</p>

<h3 id="in-terms-of-maintenance-1">In terms of maintenance</h3>

<p>N/A. We <em>improve</em> maintainability by reducing the number of artifacts we need to test.</p>

<p>Any validations and/or computations can be extracted unto their own functions (whether static or
member functions) of the constructor‚Äôs type.</p>
:ET