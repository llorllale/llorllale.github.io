I"ê+<p>One of my pet peeves of the <code class="language-plaintext highlighter-rouge">Object.equals()</code> and <code class="language-plaintext highlighter-rouge">Object.hashCode()</code> implementations that every class inherits in Java is the fact that, in principle, these are <em>really intimate</em> concerns of the class implementation, and that <code class="language-plaintext highlighter-rouge">Object</code>, a class that can be far removed from a user-defined type, should not be dictating what <em>equality</em> means to a descendant.</p>

<p>I mean, if I had to guess, I‚Äôd say that James Gosling, creator of the Java programming language, was already [righteously] thinking of collections when designing Java, but gave <strong>no</strong> thought to <em>union types</em>.</p>

<h3 id="enter-union-types">Enter union types</h3>
<p>It turns out that since generics were first introduced in Java, <a href="https://stackoverflow.com/a/42686/1623885">union of types</a> has been supported! Consider this example:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Intersection</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span> <span class="o">&amp;</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="k">default</span> <span class="kt">int</span> <span class="nf">doSomething</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span> <span class="no">T</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">t1</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">t2</span><span class="o">)</span> <span class="o">+</span> <span class="n">t1</span><span class="o">.</span><span class="na">byteValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Pay attention to the implementation of <code class="language-plaintext highlighter-rouge">doSomething</code>: <code class="language-plaintext highlighter-rouge">t1</code> holds methods of both <code class="language-plaintext highlighter-rouge">Comparable</code> and <code class="language-plaintext highlighter-rouge">Number</code>!</p>

<p>Having learned all this, I believe if Java had supported <code class="language-plaintext highlighter-rouge">union types</code> when it introduced <code class="language-plaintext highlighter-rouge">Object.equals()</code> and <code class="language-plaintext highlighter-rouge">Object.hashCode()</code>, then logically the latter two should have been introduced in their own two interfaces, perhaps <code class="language-plaintext highlighter-rouge">Equality&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Hashcode</code> respectively.</p>

<p>But first:</p>

<h4 id="reference-equality">Reference equality</h4>
<p>Java already provides the <code class="language-plaintext highlighter-rouge">==</code> operator, otherwise known as the <code class="language-plaintext highlighter-rouge">reference equality</code> operator. That is, if two references, <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code>, point to the same object in the heap, then <code class="language-plaintext highlighter-rouge">X == Y</code> will equal <code class="language-plaintext highlighter-rouge">true</code>.</p>

<h4 id="objecthashcode">Object.hashCode()</h4>
<p>The default implementation of <code class="language-plaintext highlighter-rouge">Object.hashCode()</code> is a native method call that <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/Object.java#Object.hashCode()">‚Äútypically ‚Ä¶ [converts] the internal address of the object into an integer‚Äù</a>.</p>

<h4 id="objectequals">Object.equals()</h4>
<p>The default implementation of <code class="language-plaintext highlighter-rouge">Object.equals()</code> is precisely a <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/Object.java#Object.equals(java.lang.Object)">reference comparison</a>!</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">other</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>In other words, whoever needs to perform the default ‚Äúequality comparison‚Äù on an object already has the <code class="language-plaintext highlighter-rouge">==</code> operator at his disposal - no API contract required! Moreover, this violates the aforementioned principle, elegantly exposed by Brian Goetz - current Java language architect - while responding to a <a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html">related inquiry</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>The decision about equals/hashCode behavior is so fundamental that it 
should belong to the writer of the class, at the time the class is first 
written...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is another reason why <code class="language-plaintext highlighter-rouge">equals()</code> and <code class="language-plaintext highlighter-rouge">hashCode()</code> are best left as interface contracts to be implemented in classes, eg.:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//assume the declaration for Equality was legal in Java</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Equality</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="no">T</span> <span class="n">other</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HashCode</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">code</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>‚Ä¶ and any code with requirements on the equality or hashCode amongst instances of the types it accepts should really declare its <em>intent</em> via its API, eg.:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span> <span class="kd">extends</span> <span class="nc">Equality</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="nc">HashCode</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p><strong>[EDIT 2017-11-05]</strong></p>

<p>Reading back on this as I prepare my post on the new ‚Äòdata class‚Äô proposal in project amber, I realized that the above interface proposals can be improved a bit:</p>

<p>Analyzing the <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals-java.lang.Object-">equals()</a> vs. the <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode--">hashCode()</a> contracts, it becomes obvious that despite mention of <code class="language-plaintext highlighter-rouge">hashCode()</code> in the <code class="language-plaintext highlighter-rouge">equals()</code> javadoc, the latter‚Äôs implementation <em>does not depend on the former‚Äôs</em>. However, <code class="language-plaintext highlighter-rouge">hashCode()</code> <strong>does</strong> make demands of <code class="language-plaintext highlighter-rouge">equals()</code>. Therefore, I amend my interface proposal to:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Equality</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="no">T</span> <span class="n">other</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Specifications for the requisites on Equality#equals
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HashCode</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Equality</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">code</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">//and Map's declaration would clear up a bit</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span> <span class="kd">extends</span> <span class="nc">HashCode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>It is now clear that a) <code class="language-plaintext highlighter-rouge">equality</code> does not require an object to be <em>hashable</em>, and b) <code class="language-plaintext highlighter-rouge">hashCode</code> is a separate concern intended to improve performance of <em>some</em> collections that require <code class="language-plaintext highlighter-rouge">Equality#equals</code> to behave a certain way in order for those collections to behave properly.</p>
:ET