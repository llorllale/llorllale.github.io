I"è<p>I was recently confounded by a something unexpected in Java‚Äôs type-erasure. Consider the following snippets:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Issue</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">list</span><span class="o">()</span> <span class="o">{</span>
    <span class="cm">/* return a list */</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="nc">Issue</span> <span class="n">issue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Issue</span><span class="o">();</span>        <span class="c1">//notice the use of the raw type</span>
  <span class="kd">final</span> <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">issue</span><span class="o">.</span><span class="na">list</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>   <span class="c1">//DOES NOT COMPILE</span>
<span class="o">}</span></code></pre></figure>

<p>It turns out that all generic type information is erased from an instance of a raw type - <em>including</em> all <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.8">instance methods and non-static fields</a> that have nothing to do with the type parameter declared in the class declaration. In the example above, <code class="language-plaintext highlighter-rouge">issue.list()</code> returns a <em>raw</em> <code class="language-plaintext highlighter-rouge">List</code> from which you can‚Äôt extract a <code class="language-plaintext highlighter-rouge">String</code>.</p>

<p>Getting around this limitation depends on your context. If the calling code has the option of defining the type parameter at runtime, then the fix is as easy as <code class="language-plaintext highlighter-rouge">final Issue&lt;?&gt; issue = new Issue&lt;&gt;(); final String s = issue.list().get(0);</code>. My situation was different though: due to an internal implementation detail, my interface‚Äôs generic type declaration leaked out into its public API, even though it was never my intention for the calling code to be able to provide implementations of my interface. My final solution was getting rid of the generic type declaration entirely, albeit at the cost of a less-than-perfect separation of concerns in my internal implementation.</p>

<p>Why does Java behave this way? ‚ÄúBackwards-compatibility issues‚Äù. ¬Ø\_(„ÉÑ)_/¬Ø</p>
:ET