I"ù<p>There is a new draft proposal for Java ‚ÄòData Classes‚Äô being worked on in project <em>amber</em> - read about it <a href="http://cr.openjdk.java.net/~briangoetz/amber/datum.html">here</a>. In short I think the main points are:</p>

<ul>
  <li><strong>Design intent</strong>: clearly and unequivocally express the design intent of a class as a ‚ÄòDTO‚Äô (even though the author never mentions <em>DTO</em>)</li>
  <li><strong>Boilerplate</strong>: let the compiler take care of proper implementations of typical DTO operations like <code class="language-plaintext highlighter-rouge">equals()</code> and <code class="language-plaintext highlighter-rouge">hashCode()</code></li>
  <li><strong>Switch statements</strong>: the author briefly talks about enabling semantic features around these DTOs, eg. the ability to use them as targets for <code class="language-plaintext highlighter-rouge">switch</code> statements</li>
</ul>

<p>The draft also goes into some specifics like accessors not necessarily following JavaBeans conventions, opt-in mutability, and migration/compatibility concerns, among others.</p>

<p>Let me tell you why I think this proposal <strong>is a bad idea</strong>.</p>

<p><strong>Design intent</strong>:</p>

<p>This is an honorable goal: it will immediately be obvious to a reader what the design intent of a <em>data class</em> is. The reader wouldn‚Äôt have to wade through countless lines following the typical getters and setters, <code class="language-plaintext highlighter-rouge">equals</code>, <code class="language-plaintext highlighter-rouge">hashCode</code>, and <code class="language-plaintext highlighter-rouge">toString</code> implementations just to be sure that this class is just a <em>data class</em>. Fine.</p>

<p>To see the problem with this line of thinking you must first step back and ask yourself: how many DTO-types have I defined in my project and will this new language construct simplify my code considerably? If your answer is ‚Äú<em>a lot</em>‚Äù to both questions, you have a <em>deeper</em> problem that this new construct cannot solve: <strong><em>you may not be thinking in an object-oriented way</em></strong>. Many of the types you‚Äôve defined are merely <em>bags of data</em> and you are most likely programming in an <em>imperative</em> style, not object-oriented as you <em>should</em> be with Java. <strong>That is the crux of my argument.</strong></p>

<p>Let‚Äôs kill the obvious retort right away: <em>DTO IS an antipattern but pure OOP is not practical therefore there‚Äôs no point in judging and getting upset about it</em>.</p>

<p>Yes, DTO is unavoidable sometimes, especially when interfacing with remote APIs (eg. JAX-WS). However, a couple of points:</p>

<ol>
  <li>These should exist at the <em>periphery</em> of your code</li>
  <li>They should be encapsulated by your domain model, where operations like <code class="language-plaintext highlighter-rouge">equals()</code> and <code class="language-plaintext highlighter-rouge">hashCode()</code> truly matter</li>
</ol>

<p>In essence, you must avoid <a href="https://www.martinfowler.com/bliki/AnemicDomainModel.html">anemic domain models</a>. DTOs, if present, should only exist at the <em>fringes</em> of your project, and <em>not</em> form the backbone of your whole design philosophy. They should <em>ideally</em> only be present when auto-generated by framework/tools like <code class="language-plaintext highlighter-rouge">wsimport</code> and you should never have to touch them.</p>

<p><strong>Boilerplate</strong>:</p>

<p>If you accept the previous argument, then the getter/setter ‚Äúboilerplate‚Äù becomes a <em>non-issue</em>: tools will automatically create them <em>only where you absolutely need them</em>. In regards to the proposal, that leaves us with just the other <code class="language-plaintext highlighter-rouge">Object</code> methods of interest: <code class="language-plaintext highlighter-rouge">equals()</code> and <code class="language-plaintext highlighter-rouge">hashCode()</code>. Here‚Äôs what I think:</p>

<p>They should be taken out of <code class="language-plaintext highlighter-rouge">Object</code> and <a href="/java-s-equals-hashcode-should-not-have-been-declared-in-object">made into their own interfaces</a>.</p>

<p>Not all APIs want or even need all their DTOs to implement <code class="language-plaintext highlighter-rouge">equals()</code>, much less <code class="language-plaintext highlighter-rouge">hashCode()</code>.</p>

<p><strong>Switch statements</strong>:</p>

<p>This is cool but, why not switch on any object using <code class="language-plaintext highlighter-rouge">Object#equals</code> (or on my proposed <code class="language-plaintext highlighter-rouge">Equality</code> interface)? Because of performance reasons? They already reached a compromise on switching on strings. And as an SO user so eloquently put it (<a href="https://stackoverflow.com/a/31671438/1623885">source</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>...technical obstacles shouldn‚Äôt drive language design. If there is no way to compile it to efficient 
code, it might still get compiled to the equivalent of if ‚Ä¶ else ‚Ä¶ clauses, and still have a win on 
source code brevity.
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="the-bottom-line">The bottom line</h3>

<p>By promoting DTOs to <em>first-class citizenship</em>, novice programmers who don‚Äôt know better will feel emboldened to keep abusing the DTO pattern. The other interest group - the implementators of ‚Äúinterface APIs‚Äù like Hibernate or jax-ws-ri - will gain some marginal benefit by having their templates reduced by a few lines.</p>

<p><strong>This proposal will overall promote bad design with only marginal benefits.</strong></p>

<p>Why not focus on other, <em>good</em> patterns?</p>
:ET