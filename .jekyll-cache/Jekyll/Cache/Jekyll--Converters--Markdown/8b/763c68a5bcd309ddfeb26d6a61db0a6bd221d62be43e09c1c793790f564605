I"a;<p><em>This post is part of a <a href="https://llorllale.github.io/tags/#learning-go">series</a> where I do my best to organize my thoughts around Go: its paradigms and usability as a programming language. I write this as a Java programmer that respects the principles of <a href="https://www.elegantobjects.org/">Elegant Objects</a>.</em></p>

<h2 id="what-are-elegant-containers">What are “Elegant Containers”?</h2>

<p><a href="https://www.elegantobjects.org/"><em>EO style</em></a> containers maximize the reuse of the highest abstractions possible, do not add unnecessary attributes or “getters”, and earn our respect because they <a href="https://martinfowler.com/bliki/TellDontAsk.html">know how to do their job</a>.</p>

<h2 id="scenario">Scenario</h2>

<p>We need to create and fetch products. We also need to segregate products into regular and premium classes. Premium products cannot be priced below $1000.</p>

<h3 id="java-example">Java Example</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Products</span> <span class="kd">extends</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">fetch</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">);</span>
    <span class="nc">Product</span> <span class="nf">create</span><span class="o">(</span><span class="nc">Float</span> <span class="n">price</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">AllProducts</span> <span class="kd">implements</span> <span class="nc">Products</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Premium</span> <span class="kd">implements</span> <span class="nc">Products</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Float</span> <span class="no">MINIMUM</span> <span class="o">=</span> <span class="mi">1000</span><span class="n">f</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Products</span> <span class="n">all</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Premium</span><span class="o">(</span><span class="nc">Products</span> <span class="n">all</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">all</span> <span class="o">=</span> <span class="n">all</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// overridden</span>
    <span class="kd">public</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">fetch</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">all</span><span class="o">.</span><span class="na">fetch</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">prod</span> <span class="o">-&gt;</span> <span class="n">prod</span><span class="o">.</span><span class="na">price</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="no">MINIMUM</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// overridden</span>
    <span class="kd">public</span> <span class="nc">Product</span> <span class="nf">create</span><span class="o">(</span><span class="nc">Float</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">price</span> <span class="o">&lt;</span> <span class="no">MINIMUM</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">all</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// overridden</span>
    <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Filtered</span><span class="o">&lt;&gt;(</span>		<span class="c1">// org.cactoos.iterator.Filtered</span>
            <span class="n">prod</span> <span class="o">-&gt;</span> <span class="n">prod</span><span class="o">.</span><span class="na">price</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="no">MINIMUM</span><span class="o">,</span>
            <span class="k">this</span><span class="o">.</span><span class="na">all</span><span class="o">.</span><span class="na">iterator</span><span class="o">()</span>
        <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This design has several interesting properties:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Products</code> can be iterated over in a <code class="language-plaintext highlighter-rouge">for-each</code> loop</li>
  <li>The semantics of “<code class="language-plaintext highlighter-rouge">Products</code> IS-A <code class="language-plaintext highlighter-rouge">Iterable&lt;Product&gt;</code>” just works</li>
  <li>Any <code class="language-plaintext highlighter-rouge">Product</code> created will be viewable in a subsequent <code class="language-plaintext highlighter-rouge">for-each</code> traversal</li>
  <li>High cohesion: <code class="language-plaintext highlighter-rouge">AllProducts</code> focuses on all products, while <code class="language-plaintext highlighter-rouge">Premium</code> focuses on enforcing premium pricing rules.</li>
  <li>Any <code class="language-plaintext highlighter-rouge">Iterable&lt;Product&gt;</code> can be decorated with another <code class="language-plaintext highlighter-rouge">Iterable&lt;Product&gt;</code></li>
  <li>Iteration is lazily-evaluated</li>
</ol>

<h3 id="can-it-be-done-in-go">Can it be done in Go?</h3>

<p><strong>Elephant in the room:</strong> <code class="language-plaintext highlighter-rouge">range</code> only works on arrays and slices (those two are the only applicable types within scope of this blog post). That’s right: unlike in Java, canonical <em>for-each</em> loops in <em>Go</em> can only be done against arrays or slices, instead of against an interface. This immediately negates several points above.</p>

<p class="notice">Not iterating against an interface means decorators lose the ability to lazyily evaluate the decorated object. This has implications for performance.</p>

<p>However way you slice it, any “iterable” decorators will have to preload the entire decorated array and operate on that.</p>

<p>So, barring that, how would this all look like in <em>Go</em>?</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Product</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Id</span><span class="p">()</span> <span class="kt">int</span>
	<span class="n">Price</span><span class="p">()</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="c">// Our "elegant" container. Notice this type doesn't implement an interface.</span>
<span class="k">type</span> <span class="n">Products</span> <span class="p">[]</span><span class="n">Product</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Products</span><span class="p">)</span> <span class="n">Create</span><span class="p">(</span><span class="n">price</span> <span class="kt">float64</span><span class="p">)</span> <span class="n">Product</span> <span class="p">{</span>
	<span class="n">prod</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">product</span><span class="p">{</span><span class="n">id</span><span class="o">:</span> <span class="m">123</span><span class="p">,</span> <span class="n">price</span><span class="o">:</span> <span class="n">price</span><span class="p">}</span>
	<span class="n">tmp</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span> <span class="c">// compiler would not allow p = &amp;(append(*p, prod))</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span>                <span class="c">// the problem here is that the caller still retains the original handle to `p`</span>
	<span class="k">return</span> <span class="n">prod</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Products</span><span class="p">)</span> <span class="n">Fetch</span><span class="p">(</span><span class="n">id</span> <span class="kt">int</span><span class="p">)</span> <span class="n">Product</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">prod</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">*</span><span class="n">p</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">prod</span><span class="o">.</span><span class="n">Id</span><span class="p">()</span> <span class="o">==</span> <span class="n">id</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">prod</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c">// idiomatic Go signals "not found" using `nil`</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// Our "decorator". Notice this is a completely different type than `Products`</span>
<span class="k">type</span> <span class="n">Premium</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Products</span>
	<span class="n">threshold</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Premium</span><span class="p">)</span> <span class="n">Fetch</span><span class="p">(</span><span class="n">id</span> <span class="kt">int</span><span class="p">)</span> <span class="n">Product</span> <span class="p">{</span>
	<span class="n">prod</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">Products</span><span class="o">.</span><span class="n">Fetch</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">prod</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">prod</span><span class="o">.</span><span class="n">Price</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">.</span><span class="n">threshold</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">prod</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Premium</span><span class="p">)</span> <span class="n">Create</span><span class="p">(</span><span class="n">price</span> <span class="kt">float64</span><span class="p">)</span> <span class="n">Product</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">price</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="n">threshold</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">"illegal price"</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">Products</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">price</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>There are a couple of problems here;</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Products</code> is not a “smart” container - see point #3 in the Java proposal. You would have to manually <code class="language-plaintext highlighter-rouge">append</code> the newly-created <code class="language-plaintext highlighter-rouge">Product</code> to <code class="language-plaintext highlighter-rouge">Products</code></li>
  <li><code class="language-plaintext highlighter-rouge">Premium</code> is <strong>NOT</strong> a <code class="language-plaintext highlighter-rouge">Products</code>:</li>
</ol>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Test</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">prods</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="n">Products</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="n">test</span><span class="p">(</span><span class="n">prods</span><span class="p">)</span>
	<span class="n">premium</span> <span class="o">:=</span> <span class="n">Premium</span><span class="p">{</span><span class="n">Products</span><span class="o">:</span> <span class="n">prods</span><span class="p">,</span> <span class="n">threshold</span><span class="o">:</span> <span class="m">1000</span><span class="p">}</span>
	<span class="n">test</span><span class="p">(</span><span class="n">premium</span><span class="p">)</span> 	<span class="c">// compiler error: cannot use premium (type Premium) as type Products</span>
<span class="p">}</span></code></pre></figure>

:ET