I"Å<p><em>This is the first in a <a href="https://llorllale.github.io/tags/#learning-go">series</a> of posts where I do my best to organize my thoughts around Go: its paradigms and usability as a programming language. I write this as a Java programmer that respects the principles of <a href="https://www.elegantobjects.org/">Elegant Objects</a>.</em></p>

<p><a href="https://golang.org/">Go</a> has structs - which are essentially <a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTOs</a> - and the ability to implement methods on these structs by specifying <a href="https://tour.golang.org/methods/1">receivers</a> on functions.</p>

<p>Go allows one to call methods on <code class="language-plaintext highlighter-rouge">nil</code> references because, although functions and structs are both equally first-class citizens, <em>functions are more equal than structs</em> (hence this post‚Äôs feature image).</p>

<h2 id="what-are-methods-on-nil-references-good-for">What are methods on <code class="language-plaintext highlighter-rouge">nil</code> references good for?</h2>

<p>Consider this API:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">people</span>

<span class="k">type</span> <span class="n">Person</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Name</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// GetPerson returns nil indicating the person was not found</span>
<span class="k">func</span> <span class="n">GetPerson</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="n">Person</span> <span class="p">{</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">person</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">person</span><span class="p">)</span> <span class="n">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
<span class="p">}</span>	</code></pre></figure>

<p>Our <strong>test code</strong> will panic if <code class="language-plaintext highlighter-rouge">nil</code> is returned by <code class="language-plaintext highlighter-rouge">GetPerson()</code>:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go">	<span class="n">person</span> <span class="o">:=</span> <span class="n">GetPerson</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">person</span><span class="o">.</span><span class="n">Name</span><span class="p">())</span> 	<span class="c">// panic: invalid memory address or nil pointer dereference</span></code></pre></figure>

<p>There are several ways the API can be improved in order to signal that this person was not found; I‚Äôm not sure which one is more idiomatic in <em>Go</em>. Let‚Äôs consider implementing the <a href="https://en.wikipedia.org/wiki/Null_object_pattern">Null Object Pattern</a> by exploiting the fact that you can execute methods on <code class="language-plaintext highlighter-rouge">nil</code> references.</p>

<p>Let‚Äôs modify the <code class="language-plaintext highlighter-rouge">Name()</code> implementation on our <code class="language-plaintext highlighter-rouge">person</code> struct:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">person</span><span class="p">)</span> <span class="n">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">"person was not found"</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
<span class="p">}</span></code></pre></figure>

<p>Our <strong>test code</strong> will now print <code class="language-plaintext highlighter-rouge">person was not found</code>.</p>

<p>Now <code class="language-plaintext highlighter-rouge">Person</code> has a dual nature: depending on circumstances, it can be a normal person with a name, or it can be an ‚Äúinvalid‚Äù person. This is an additional cognitive burden when trying to understand this struct. <code class="language-plaintext highlighter-rouge">person</code> is now <strong>unfocused</strong>, breaking the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>.</p>

<p class="notice"><strong>I don‚Äôt know what good methods on nil references are for.</strong></p>

:ET