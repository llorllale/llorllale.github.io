I"p<p><em>This post is part of a <a href="https://llorllale.github.io/tags/#learning-go">series</a> where I do my best to organize my thoughts around Go: its paradigms and usability as a programming language. I write this as a Java programmer that respects the principles of <a href="https://www.elegantobjects.org/">Elegant Objects</a>.</em></p>

<h2 id="what-are-elegant-containers">What are “Elegant Containers”?</h2>

<p><a href="https://www.elegantobjects.org/"><em>EO style</em></a> containers maximize the reuse of the highest abstractions possible, do not add unnecessary attributes or “getters”, and earn our respect because they <a href="https://martinfowler.com/bliki/TellDontAsk.html">know how to do their job</a>.</p>

<h2 id="scenario">Scenario</h2>

<p>We need to create and fetch products. We also need to segregate products into regular and premium classes. Premium products cannot be priced below $1000.</p>

<h3 id="java-example">Java Example</h3>

<p>{% highlight java %}
public interface Products extends Iterable<Product> {
    Optional<Product> fetch(Long id);
    Product create(Float price);
}</Product></Product></p>

<p>public final class AllProducts implements Products {
    …
}</p>

<p>public final class Premium implements Products {
    private static final Float MINIMUM = 1000f;
    private final Products all;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>public Premium(Products all) {
    this.all = all;
}

// overridden
public Optional&lt;Product&gt; fetch(Long id) {
    return this.all.fetch(id).filter(prod -&gt; prod.price() &gt;= MINIMUM);
}

// overridden
public Product create(Float price) {
    if (price &lt; MINIMUM) {
        throw new IllegalArgumentException();
    }
    return this.all.create(price);
}

// overridden
public Iterator&lt;Product&gt; iterator() {
    return new Filtered&lt;&gt;(		// org.cactoos.iterator.Filtered
        prod -&gt; prod.price() &gt;= MINIMUM,
        this.all.iterator()
    );
} } {% endhighlight %}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This design has several interesting properties:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Products</code> can be iterated over in a <code class="language-plaintext highlighter-rouge">for-each</code> loop</li>
  <li>The semantics of “<code class="language-plaintext highlighter-rouge">Products</code> IS-A <code class="language-plaintext highlighter-rouge">Iterable&lt;Product&gt;</code>” just works</li>
  <li>Any <code class="language-plaintext highlighter-rouge">Product</code> created will be viewable in a subsequent <code class="language-plaintext highlighter-rouge">for-each</code> traversal</li>
  <li>High cohesion: <code class="language-plaintext highlighter-rouge">AllProducts</code> focuses on all products, while <code class="language-plaintext highlighter-rouge">Premium</code> focuses on enforcing premium pricing rules.</li>
  <li>Any <code class="language-plaintext highlighter-rouge">Iterable&lt;Product&gt;</code> can be decorated with another <code class="language-plaintext highlighter-rouge">Iterable&lt;Product&gt;</code></li>
  <li>Iteration is lazily-evaluated</li>
</ol>

<h3 id="can-it-be-done-in-go">Can it be done in Go?</h3>

<p><strong>Elephant in the room:</strong> <code class="language-plaintext highlighter-rouge">range</code> only works on arrays and slices (those two are the only applicable types within scope of this blog post). That’s right: unlike in Java, canonical <em>for-each</em> loops in <em>Go</em> can only be done against arrays or slices, instead of against an interface. This immediately negates several points above.</p>

<p class="notice">Not iterating against an interface means decorators lose the ability to lazyily evaluate the decorated object. This has implications for performance.</p>

<p>However way you slice it, any “iterable” decorators will have to preload the entire decorated array and operate on that.</p>

<p>So, barring that, how would this all look like in <em>Go</em>?</p>

<p>{% highlight go %}
type Product interface {
	Id() int
	Price() float64
}</p>

<p>// Our “elegant” container. Notice this type doesn’t implement an interface.
type Products []Product</p>

<p>func (p <em>Products) Create(price float64) Product {
	prod := &amp;product{id: 123, price: price}
	tmp := append(</em>p, prod) // compiler would not allow p = &amp;(append(*p, prod))
	p = &amp;tmp                // the problem here is that the caller still retains the original handle to <code class="language-plaintext highlighter-rouge">p</code>
	return prod
}</p>

<p>func (p *Products) Fetch(id int) Product {
	for _, prod := range *p {
		if prod.Id() == id {
			return prod
		}
	}
	// idiomatic Go signals “not found” using <code class="language-plaintext highlighter-rouge">nil</code>
	return nil
}</p>

<p>// Our “decorator”. Notice this is a completely different type than <code class="language-plaintext highlighter-rouge">Products</code>
type Premium struct {
	Products
	threshold float64
}</p>

<p>func (p *Premium) Fetch(id int) Product {
	prod := p.Products.Fetch(id)
	if prod != nil &amp;&amp; prod.Price() &gt;= p.threshold {
		return prod
	}
	return nil
}</p>

<p>func (p *Premium) Create(price float64) Product {
	if price &lt; p.threshold {
		panic(“illegal price”)
	}
	return p.Products.Create(price)
}
{% endhighlight %}</p>

<p>There are a couple of problems here;</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Products</code> is not a “smart” container - see point #3 in the Java proposal. You would have to manually <code class="language-plaintext highlighter-rouge">append</code> the newly-created <code class="language-plaintext highlighter-rouge">Product</code> to <code class="language-plaintext highlighter-rouge">Products</code></li>
  <li><code class="language-plaintext highlighter-rouge">Premium</code> is <strong>NOT</strong> a <code class="language-plaintext highlighter-rouge">Products</code>:
{% highlight go %}
func Test(t *testing.T) {
 prods := make(Products, 0)
 test(prods)
 premium := Premium{Products: prods, threshold: 1000}
 test(premium) 	// compiler error: cannot use premium (type Premium) as type Products
}
{% endhighlight %}</li>
</ol>
:ET